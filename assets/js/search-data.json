{
  
    
        "post0": {
            "title": "Shock response with SEA - What to expect?",
            "content": "Shock response with SEA - What to expect? . I got a chance to revisit an application of Statistical Energy Analysis (SEA) during some course work at KTH; the application of predicting high frequency shock response of plate-like structures, which I researched in my Masters Thesis one and a half decade ago. The analysed structure is shown below, comprised of five connected metal plates. . | | . Shock waves in structures due to sudden release of energy are common in aerospace applications. Explosive bolts to separate rocket stages, latches and deployment of appendices are some examples. The shock load is often short in time and the frequency content of the propagating waves are high. In some cases, the analysis is performed up to 100 kHz. This requires a high element-density when using FE-methods to predict the shock wave propagation. That’s where SEA comes in to play. . Statistical Energy Analysis (SEA) . SEA was developed for analysing mid- to high-frequency acoustics and has been later on become a tool in vibro-acoustics. Instead of a calculating the deterministic responses of structures, a statistical approach is done by considering an average response of similar sub-structures. An “element” can be one of the plates in the presented structure. . A typical two-subsystem arrangement, depicted in the figure below, is commonly used to demonstrate the power flow in SEA. . . $E_i$ represents the vibro-acoustic energy of $i$:th subsystem and the power input to each system is $P_i$. Each subsystem has a power-loss, $ omega eta_i E_i$, where $ omega$ is the analysed center-frequency and $ eta_i$ is the loss factor. The energy exchange between the two subsystems are governed by the coupling loss factor $ eta_{12}$ and the reciprocal loss factor $ eta_{21}$. The power balance for the system may be set up and written . P1=ωη1E1+ωη12η1(E1n1−E2n2)P_1 = omega eta_1 E_1 + omega eta_{12} eta_{1} left( frac{E_1}{n_1} - frac{E_2}{n_2} right)P1​=ωη1​E1​+ωη12​η1​(n1​E1​​−n2​E2​​), . P2=ωη2E2+ωη21η2(E2n2−E1n1)P_2 = omega eta_2 E_2 + omega eta_{21} eta_{2} left( frac{E_2}{n_2} - frac{E_1}{n_1} right)P2​=ωη2​E2​+ωη21​η2​(n2​E2​​−n1​E1​​), . where the modal density $n_i$ of the $i$:th subsystem has been introduced. This system of equations may be solved for the energy and the spatial averaged velocity squared may be calculated by, $v^2 = E_i / m_i $, where $m$ is the mass of the subsystem. The Shock Response Spectrum (SRS) is commonly used to evaluate the shock severity. Anyhow, let us keep it simple and stick to analysing the velocity and acceleration responses. . What to expect? . So, to the main question. What results can we expect from SEA in comparison to a deterministic approach? In SEA, there is no modal content since we only look at the spatial averaged response, based on the vibro-acoustic energy of the sub-systems. For a deterministic method, the eigen-frequencies will be visible in the low frequency range when the modes are well separated. However, as the frequency increases, the eigen-frequencies start to overlap and individual modes are hard to spot, thus, we have a higher modal density at higher frequencies. SEA is only valid at high frequencies where the modal density is sufficiently large. Let us visualize this in an example of a simply supported plate excited by a half-sine impulse of 200 $ mu s$. . The blue dotted line in the figure to the right shows the average-velocity of 30 random points on the plate in third-octave bands, calculated by the (deterministic) mode summation technique and the green line is calculated with SEA. At 3-4 kHz we see how the results converge. Thus, the modal density is sufficiently high for SEA to be valid. . . As a final example, let us excite the previously presented five-plate structure with a 1 ms Haversine impulse at the lower end of plate 1 and compare the SEA results with the results from a FE-model of the structure. In the figure below, we see the spatial average acceleration of the individual five plates, respectively. The dashed lines are from the FE-model and the solid lines are from SEA model. Here, we also see that the results converge more and more as the frequency increases and the modal density increases. We have a rather good agreement between the two methods in the high-frequency region. The high-frequency results from the FE-model is however limited by the choice of element size. The element size was chosen to give reasonable simulation time on the cost of limiting the upper frequency range. Nevertheless, this is where SEA can take over, showing how the two methods can be used in conjunction. . . Conclusion . SEA is a statistical approach by considering an average response of similar sub-structures and is only valid at high frequencies where the modal density is sufficiently large. Individual modes are not considered in the low-frequency region as compared to deterministic approaches. SEA is a suitable method for high-frequency shock analysis and a good complementary tool to FE-methods. .",
            "url": "https://virtualacoustics.github.io/posts/shock%20analysis/2020/08/21/Shock-Response.html",
            "relUrl": "/shock%20analysis/2020/08/21/Shock-Response.html",
            "date": " • Aug 21, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Double pendulum with torsion damper",
            "content": "import sympy as sp import sympy.physics.mechanics as me me.init_vprinting() q1, q2 = me.dynamicsymbols(&#39;q1, q2&#39;) # Generalized coordinates as function of time qd1, qd2 = me.dynamicsymbols(&#39;q1, q2&#39;, level=1) # Time-derivative of generalized coordinates u1, u2 = me.dynamicsymbols(&#39;u1, u2&#39;) # Generalized speeds (function of time) l, m, g = sp.symbols(&#39;l, m, g&#39;) # Constants sig, delta = sp.symbols(&#39;sigma, delta&#39;) # Force parameters . Orient the reference frames: . N = me.ReferenceFrame(&#39;N&#39;) # Inertial frame A = N.orientnew(&#39;A&#39;, &#39;Axis&#39;, (q1, N.z)) # Rod A frame B = A.orientnew(&#39;B&#39;, &#39;Axis&#39;, (q2, N.z)) # Rod B frame . Kinematics . Rotational motion: $$ boldsymbol{ omega}^{A} = dot{q}_1 mathbf{ hat{n}_z}, qquad boldsymbol{ omega}^{B} = ( dot{q}_1 + dot{q}_2) mathbf{ hat{n}_{z}}$$ . A.ang_vel_in(N).express(N) . $ displaystyle dot{q}_{1} mathbf{ hat{n}_z}$ B.ang_vel_in(N).express(N) . $ displaystyle ( dot{q}_{1} + dot{q}_{2}) mathbf{ hat{n}_z}$ Choose generalized speeds as: . $$u_1 = dot{q}_1, qquad u_2 = dot{q}_1 + dot{q}_2$$ so $$ boldsymbol{ omega}^{A} = u_1 mathbf{ hat{n}_z}, qquad boldsymbol{ omega}^{B} = u_2 mathbf{ hat{n}_{z}}$$. . kde = [u1 - qd1, u2 - (qd1 + qd2)] # Kinematical differential equation . Differentiation of vector: . $$ frac{^{N}d mathbf{r}}{d t} = frac{^{A}d mathbf{r}}{d t} + ^{N} omega^{A} times mathbf{r} $$ . or by the two-point formula $$^{N} mathbf{v}^{ mathcal{P}} = ^{A} mathbf{v}^{ mathcal{O}} + ^{N} boldsymbol{ omega}^{A} times mathbf{r}_{ mathcal{OP}}.$$ . Calculate the velocities of $ mathcal{P}$ and $ mathcal{Q}$: . Position vectors: . $$ mathbf{r}^{ mathcal{OP}} = - l mathbf{ hat{a}_y}$$ . $$ mathbf{r}^{ mathcal{OQ}} = - l mathbf{ hat{a}_y} - l mathbf{ hat{b}_y}$$ . Velocities: . $$ mathbf{v}^{ mathcal{P}} = l u_1 mathbf{ hat{a}_x}$$ . $$ mathbf{v}^{ mathcal{Q}} = l u_1 mathbf{ hat{a}_x} + l u_2 mathbf{ hat{b}_x}$$ . In Sympy Mechanics: . O = me.Point(&#39;O&#39;) # Origo O.set_vel(N, 0) P = O.locatenew(&#39;P&#39;, ( -l * A.y )) # Point @ end of rod A Ap = me.Particle(&#39;Ap&#39;, P, m) # Define mass P.v2pt_theory(O, N, A) # Set velocity . $ displaystyle l dot{q}_{1} mathbf{ hat{a}_x}$ Q = P.locatenew(&#39;Q&#39;, ( -l * B.y)) # Point @ end of rod B Bp = me.Particle(&#39;Bp&#39;, Q, m) Q.v2pt_theory(P, N, B) # Set velocity . $ displaystyle l dot{q}_{1} mathbf{ hat{a}_x} + l left( dot{q}_{1} + dot{q}_{2} right) mathbf{ hat{b}_x}$ Accelerations are needed in Kane&#39;s method: . $$ mathbf{a}^{ mathcal{P}} = l dot{u}_{1} mathbf{ hat{a}_x} + l u_{1}^{2} mathbf{ hat{a}_y}$$ . $$ mathbf{a}^{ mathcal{Q}} = l dot{u}_{1} mathbf{ hat{a}_x} + l u_{1}^{2} mathbf{ hat{a}_y} + l dot{u}_{2} mathbf{ hat{b}_x} + l u_{2}^{2} mathbf{ hat{b}_y}$$ . P.acc(N) . $ displaystyle l ddot{q}_{1} mathbf{ hat{a}_x} + l dot{q}_{1}^{2} mathbf{ hat{a}_y}$ Q.acc(N) . $ displaystyle l ddot{q}_{1} mathbf{ hat{a}_x} + l dot{q}_{1}^{2} mathbf{ hat{a}_y} + l left( ddot{q}_{1} + ddot{q}_{2} right) mathbf{ hat{b}_x} + l left( dot{q}_{1} + dot{q}_{2} right)^{2} mathbf{ hat{b}_y}$ Inertial forces . Let us calculate the inertial forces before applying forces. $$f^*_r= sum_{j=1}^{N} left[ dot{ mathbf{p}}^{B_j} cdot mathbf{v}_{r}^{B_j} ~+ dot{ mathbf{L}}^{B_j} cdot boldsymbol{ omega}_{r}^{B_j} right]$$ We have $$ mathbf{v}^{ mathcal{P}} = l u_1 mathbf{ hat{a}_x}, qquad mathbf{v}^{ mathcal{Q}} = l u_1 mathbf{ hat{a}_x} + l u_2 mathbf{ hat{b}_x}$$ . Partial velocities become . $$ mathbf{v}^{ mathcal{P}}_1 = frac{ partial{} mathbf{v}^{ mathcal{P}}}{ partial u_1} = l mathbf{ hat{a}_x}, qquad mathbf{v}^{ mathcal{Q}}_1 = frac{ partial{} mathbf{v}^{ mathcal{Q}}}{ partial u_1} = l mathbf{ hat{a}_x}, $$$$ mathbf{v}^{ mathcal{P}}_2 = frac{ partial{} mathbf{v}^{ mathcal{P}}}{ partial u_2} = mathbf{0}, qquad mathbf{v}^{ mathcal{Q}}_2 = frac{ partial{} mathbf{v}^{ mathcal{Q}}}{ partial u_2} = l mathbf{ hat{b}_x} $$ Time derivative of momentum . $$ mathbf{ dot{p}}^{ mathcal{P}} = m left(l dot{u}_{1} mathbf{ hat{a}_x} + l u_{1}^{2} mathbf{ hat{a}_y} right), quad mathbf{ dot{p}}^{ mathcal{Q}} = m left(l dot{u}_{1} mathbf{ hat{a}_x} + l u_{1}^{2} mathbf{ hat{a}_y} + l dot{u}_{2} mathbf{ hat{b}_x} + l u_{2}^{2} mathbf{ hat{b}_y} right)$$ . Evaluate the sum . $$f^*_1 = m left(l dot{u}_{1} mathbf{ hat{a}_x} + l u_{1}^{2} mathbf{ hat{a}_y} right) cdot l mathbf{ hat{a}_x} + m left(l dot{u}_{1} mathbf{ hat{a}_x} + l u_{1}^{2} mathbf{ hat{a}_y} + l dot{u}_{2} mathbf{ hat{b}_x} + l u_{2}^{2} mathbf{ hat{b}_y} right) cdot l mathbf{ hat{a}_x} = 2 m l^{2} dot{u}_{1} + m l^{2} dot{u}_{2} operatorname{cos} left(q_{2} right)- m l^{2} u^{2}_{2} operatorname{sin} left(q_{2} right)$$ . $$f^*_2 = m left(l dot{u}_{1} mathbf{ hat{a}_x} + l u_{1}^{2} mathbf{ hat{a}_y} right) cdot mathbf{0} + m left(l dot{u}_{1} mathbf{ hat{a}_x} + l u_{1}^{2} mathbf{ hat{a}_y} + l dot{u}_{2} mathbf{ hat{b}_x} + l u_{2}^{2} mathbf{ hat{b}_y} right) cdot l mathbf{ hat{b}_x} = m l^{2} dot{u}_{1} operatorname{cos} left(q_{2} right) + m l^{2} u^{2}_{1} operatorname{sin} left(q_{2} right) + m l^{2} dot{u}_{2}$$ . KM = me.KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde) fr, fstar = KM.kanes_equations([Ap, Bp], None) sp.Eq(-fstar,fr) . $ displaystyle left[ begin{matrix}- l^{2} m u^{2}_{2} operatorname{sin} left(q_{2} right) + l^{2} m operatorname{cos} left(q_{2} right) dot{u}_{2} + 2 l^{2} m dot{u}_{1} l^{2} m u^{2}_{1} operatorname{sin} left(q_{2} right) + l^{2} m operatorname{cos} left(q_{2} right) dot{u}_{1} + l^{2} m dot{u}_{2} end{matrix} right] = left[ begin{matrix}0 0 end{matrix} right]$ Forces . $$ f_{r} = sum_{j=1}^{N} left[ mathbf{F}^{B_j} ~ cdot mathbf{v}_{r}^{B_j} ~ + mathbf{T}^{B_j} cdot boldsymbol{ omega}^{B_j}_r right]$$ . Recall $$ boldsymbol{ omega}^{A} = u_1 mathbf{ hat{n}_z}, qquad boldsymbol{ omega}^{B} = u_2 mathbf{ hat{n}_{z}}$$ . Partial angular velocities . $$ boldsymbol{ omega}^{A}_1 = mathbf{ hat{n}_z}, quad boldsymbol{ omega}^{B}_1 = mathbf{0},$$ . $$ boldsymbol{ omega}^{A}_2 = mathbf{0}, quad boldsymbol{ omega}^{B}_2 = mathbf{ hat{n}_z}.$$ . Torques . $$ mathbf{T}^{A} = left( sigma q_2 + delta dot{q}_2 right) mathbf{ hat{n}_z} = left( sigma q_2 + delta left(u_2 -u_1 right) right) mathbf{ hat{n}_z} $$ . $$ mathbf{T}^{B} = - mathbf{T}^{A} $$ . Gravity . $$ mathbf{F}^{ mathcal{P}} = - g m mathbf{ hat{n}_y}$$ $$ mathbf{F}^{ mathcal{Q}} = - g m mathbf{ hat{n}_y}$$ . Evaluate the sum . Torques $$ f_{1}^T = mathbf{T}^{A} cdot mathbf{ hat{n}_z} + mathbf{T}^{B} cdot mathbf{0} = sigma q_2 + delta left(u_2 -u_1 right) $$ . $$ f_{2}^T = mathbf{T}^{A} cdot mathbf{0} + mathbf{T}^{B} cdot mathbf{ hat{n}_z} = - sigma q_2 - delta left(u_2 -u_1 right) $$ . Gravity $$ f_{1}^F = - g m mathbf{ hat{n}_y} cdot l mathbf{ hat{a}_x} - g m mathbf{ hat{n}_y} cdot l mathbf{ hat{a}_x} = - 2 g l m operatorname{sin} left(q_{1} right)$$ . $$ f_{2}^F = - g m mathbf{ hat{n}_y} cdot mathbf{0} - g m mathbf{ hat{n}_y} cdot l mathbf{ hat{b}_x} = - g l m operatorname{sin} left(q_{1} + q_{2} right) $$ . # Torque Ta = (sig * q2 + delta * qd2) * N.z # Gravity force Fg = -g*m*N.y*0 # Apply forces on frames and points forces = [(A, Ta), (B, -Ta), (P, Fg), (Q, Fg)] . Generate EOM . KM = me.KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde) # Kane&#39;s method instance fr, fstar = KM.kanes_equations([Ap, Bp], forces) # &quot;Evaluate the sum&quot; sp.Eq(-fstar,fr) # Output EOM . $ displaystyle left[ begin{matrix}- l^{2} m u^{2}_{2} operatorname{sin} left(q_{2} right) + l^{2} m operatorname{cos} left(q_{2} right) dot{u}_{2} + 2 l^{2} m dot{u}_{1} l^{2} m u^{2}_{1} operatorname{sin} left(q_{2} right) + l^{2} m operatorname{cos} left(q_{2} right) dot{u}_{1} + l^{2} m dot{u}_{2} end{matrix} right] = left[ begin{matrix} delta left(- u_{1} + u_{2} right) + sigma q_{2} - delta left(- u_{1} + u_{2} right) - sigma q_{2} end{matrix} right]$ Different generalized speeds . # Test different kde. kde1 = [u1 - qd1, u2 - qd2] # Equivalent to Lagrange KM = me.KanesMethod(N, [q1, q2], [u1, u2], kd_eqs=kde1) fr, fstar = KM.kanes_equations([Ap, Bp], forces) sp.Eq(-fstar,fr) . $ displaystyle left[ begin{matrix}- l^{2} m left(u_{1} + u_{2} right)^{2} operatorname{sin} left(q_{2} right) + l^{2} m u^{2}_{1} operatorname{sin} left(q_{2} right) + m left(l^{2} operatorname{cos} left(q_{2} right) + l^{2} right) dot{u}_{2} + left(l^{2} m + m left(2 l^{2} operatorname{cos} left(q_{2} right) + 2 l^{2} right) right) dot{u}_{1} l^{2} m u^{2}_{1} operatorname{sin} left(q_{2} right) + l^{2} m dot{u}_{2} + m left(l^{2} operatorname{cos} left(q_{2} right) + l^{2} right) dot{u}_{1} end{matrix} right] = left[ begin{matrix}0 - delta u_{2} - sigma q_{2} end{matrix} right]$",
            "url": "https://virtualacoustics.github.io/posts/2020/03/13/Kanes-method-SymPy.html",
            "relUrl": "/2020/03/13/Kanes-method-SymPy.html",
            "date": " • Mar 13, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "This website is powered by fastpages. .",
          "url": "https://virtualacoustics.github.io/posts/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://virtualacoustics.github.io/posts/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}